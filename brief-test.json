{
  "angle": "technical",
  "audience": "general readers",
  "faq": [
    {
      "answer": "LLMs extract entities via prompts that generate stable IDs for files, classes, functions, etc., using structured JSON output.",
      "question": "How do LLMs extract code entities?"
    },
    {
      "answer": "Qwen3-Coder (30B) excels in identifying important code elements, while 3B-7B models offer a balance between speed and accuracy.",
      "question": "Which models perform best for code summarization?"
    },
    {
      "answer": "LLM-based code graphs are computationally intensive, requiring optimization with ASTs and heuristics for large codebases.",
      "question": "What\u2019s the computational cost of LLM-based code graphs?"
    }
  ],
  "h1": "LLM Code Knowledge Graph: Experiments and Insights",
  "meta_description": "LLM Code Knowledge Graph: Experiments and Insights for developers seeking efficient code analysis and graph construction.",
  "outline": [
    "Introduction",
    "LLM Code Knowledge Graph Overview",
    "Three Approaches to Code Graphs",
    "Model Performance Comparison",
    "Computational Intensity and Limitations",
    "Best Practices for Local LLMs",
    "Code Extraction Process",
    "Conclusion"
  ],
  "primary_keyword": "LLM code knowledge graph",
  "search_intent": "informational",
  "secondary_keywords": [
    "code extraction",
    "model performance",
    "ASTs"
  ],
  "title": "LLM Code Knowledge Graph: Experiments and Insights"
}
